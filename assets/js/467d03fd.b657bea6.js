"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[825],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=a,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return t?o.createElement(h,i(i({ref:n},c),{},{components:t})):o.createElement(h,i({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3336:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=t(7462),a=(t(7294),t(3905));const r={slug:"/reactjs/lifeCycle",title:"React life cycle event",description:"Learn about the React component lifecycle and its equivalents in class components and functional components. Understand the different methods such as constructor, render, componentDidMount, componentDidUpdate, componentWillUnmount, and how to handle state and side effects. This comprehensive guide provides a clear explanation and examples to help you understand the React lifecycle and optimize your component updates.",sidebar_label:"Life cycle event",sidebar_position:3,keywords:["React component lifecycle","class component","functional component","constructor","getDerivedStateFromProps","render","componentDidMount","useState","useEffect","shouldComponentUpdate","componentDidUpdate","componentWillUnmount","React.memo","error handling","unmounting"]},i=void 0,s={unversionedId:"Reactjs/reactLifeCycle",id:"Reactjs/reactLifeCycle",title:"React life cycle event",description:"Learn about the React component lifecycle and its equivalents in class components and functional components. Understand the different methods such as constructor, render, componentDidMount, componentDidUpdate, componentWillUnmount, and how to handle state and side effects. This comprehensive guide provides a clear explanation and examples to help you understand the React lifecycle and optimize your component updates.",source:"@site/docs/Reactjs/reactLifeCycle.mdx",sourceDirName:"Reactjs",slug:"/reactjs/lifeCycle",permalink:"/Notes/reactjs/lifeCycle",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{slug:"/reactjs/lifeCycle",title:"React life cycle event",description:"Learn about the React component lifecycle and its equivalents in class components and functional components. Understand the different methods such as constructor, render, componentDidMount, componentDidUpdate, componentWillUnmount, and how to handle state and side effects. This comprehensive guide provides a clear explanation and examples to help you understand the React lifecycle and optimize your component updates.",sidebar_label:"Life cycle event",sidebar_position:3,keywords:["React component lifecycle","class component","functional component","constructor","getDerivedStateFromProps","render","componentDidMount","useState","useEffect","shouldComponentUpdate","componentDidUpdate","componentWillUnmount","React.memo","error handling","unmounting"]},sidebar:"tutorialSidebar",previous:{title:"useEffect",permalink:"/Notes/reactjs/useEffect"},next:{title:"index",permalink:"/Notes/accessibility/"}},l={},p=[{value:"Component Mounting",id:"component-mounting",level:2},{value:"Class Component",id:"class-component",level:3},{value:"Functional Equivalent",id:"functional-equivalent",level:3},{value:"Component Updating",id:"component-updating",level:2},{value:"Class Component",id:"class-component-1",level:3},{value:"Functional Equivalent",id:"functional-equivalent-1",level:3},{value:"Component Unmounting",id:"component-unmounting",level:2},{value:"Class Component",id:"class-component-2",level:3},{value:"Functional Equivalent",id:"functional-equivalent-2",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Class Component",id:"class-component-3",level:3},{value:"Functional Equivalent",id:"functional-equivalent-3",level:3}],c={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"component-mounting"},"Component Mounting"),(0,a.kt)("h3",{id:"class-component"},"Class Component"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"constructor(props)"),": This is a special method that initializes the component's state and binds event handlers. It is called when the component is created.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"static getDerivedStateFromProps(props, state)"),": This is a static method that allows you to update the state based on changes in props. It returns an object that represents the updated state or null if no update is needed.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"render()"),": This method is responsible for rendering the component's UI based on the current state and props. It returns a React element that represents the component's output.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"componentDidMount()"),": This method in React is called only once, immediately after the component is mounted (i.e., inserted into the DOM). It is a commonly used method for performing initialization tasks, fetching data from an API, setting up subscriptions, or performing any other actions that need to happen after the component has been rendered for the first time."))),(0,a.kt)("h3",{id:"functional-equivalent"},"Functional Equivalent"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"useState()"),": This hook allows you to declare state variables and their initial values. It returns an array with two elements: the current state value and a function to update the state.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"useEffect(() => {}, [])"),": This hook is used to handle side effects in functional components. When used with an empty dependency array, it behaves similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDidMount()"),", running the effect only once after the initial render."))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// Class Component\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props); // Call the parent class constructor\n\n    // Initialize the component's state\n    this.state = {\n      count: 0,\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (props.initialCount !== state.count) {\n      // Update state based on props\n      return {\n        count: props.initialCount\n      };\n    }\n\n    // Return null if no state update is needed\n    return null;\n  }\n\n  componentDidMount() {\n    // Perform tasks after rendering\n  }\n\n  render() {\n    // Render UI based on state and props\n  }\n}\n\n// Functional Component\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // Perform tasks after initial render\n  }, []);\n\n\n  // Render UI based on state and props\n  return ()\n}\n")),(0,a.kt)("h2",{id:"component-updating"},"Component Updating"),(0,a.kt)("h3",{id:"class-component-1"},"Class Component"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"static getDerivedStateFromProps(props, state)"),": This static method is used to update the component's state based on changes in props. It returns an object representing the updated state or null if no update is needed.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate(nextProps, nextState)"),": This method is called before rendering when new props or state are received. It allows you to control whether the component should re-render or not by returning true or false.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"render()"),": This method is responsible for rendering the component's UI based on the updated state and props.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"componentDidUpdate(prevProps, prevState)"),": This method is invoked after the component has been re-rendered. It is commonly used for performing side effects based on the updated state or props."))),(0,a.kt)("h3",{id:"functional-equivalent-1"},"Functional Equivalent"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"useEffect(() => {})"),": This hook is used to handle side effects after every render. It is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDidUpdate()")," but runs after every render, not just the first one.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"React.memo(Component)"),": This higher-order component is used to prevent unnecessary re-renders of a functional component. It compares the previous and current props and returns the cached result if the props haven't changed."))),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// Class Component\n\nclass MyComponent extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    // Update state based on new props\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Determine if re-render is needed\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // Perform tasks after update\n  }\n\n  render() {\n    // Render UI based on updated state and props\n  }\n}\n\n// Functional Component\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // Perform tasks after every render\n  });\n\n  const handleClick = () => {\n    // Update state\n  };\n\n  // Render UI based on state and props\n}\n\n// Memoized Functional Component\nconst MemoizedComponent = React.memo(MyComponent);\n")),(0,a.kt)("h2",{id:"component-unmounting"},"Component Unmounting"),(0,a.kt)("h3",{id:"class-component-2"},"Class Component"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"componentWillUnmount()"),": This method is called just before the component is removed from the DOM. It is used to clean up resources or cancel ongoing processes.")),(0,a.kt)("h3",{id:"functional-equivalent-2"},"Functional Equivalent"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"useEffect(() => { return () => {} })"),": This form of ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect()")," is used to clean up resources before unmounting. The returned function is called when the component is about to be unmounted.")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// Class Component\nclass MyComponent extends React.Component {\n  componentWillUnmount() {\n    // Clean up resources before unmounting\n  }\n}\n\n// Functional Component\nfunction MyComponent() {\n  useEffect(() => {\n    return () => {\n      // Clean up resources before unmounting\n    };\n  }, []);\n}\n")),(0,a.kt)("h2",{id:"error-handling"},"Error Handling"),(0,a.kt)("h3",{id:"class-component-3"},"Class Component"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"componentDidCatch(error, info)"),": This method is used to catch errors that occur within the component's child tree. It allows you to handle the error gracefully by displaying an error message or a fallback UI.")),(0,a.kt)("h3",{id:"functional-equivalent-3"},"Functional Equivalent"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Handling errors in functional components can be done using ",(0,a.kt)("inlineCode",{parentName:"li"},"try-catch")," blocks or by creating a custom error boundary component using higher-order components.")),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// Class Component\nclass ErrorBoundary extends React.Component {\n  componentDidCatch(error, info) {\n    // Handle errors and display fallback UI\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\n// Functional Component with try-catch\nfunction MyComponent() {\n  try {\n    // Component logic that may throw an error\n  } catch (error) {\n    // Handle the error and display fallback UI\n  }\n}\n\n// Functional Component wrapped in ErrorBoundary\nfunction MyComponent() {\n  // Component logic\n\n  return <ErrorBoundary>{/* Your component tree */}</ErrorBoundary>;\n}\n")),(0,a.kt)("p",null,"Combined All to gether in one example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import React, { useState, useEffect } from "react";\n\n// Class Component\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // Update state based on new props\n    console.log("getDerivedStateFromProps - props:", props);\n    console.log("getDerivedStateFromProps - state:", state);\n\n    return null;\n  }\n\n  componentDidMount() {\n    // Perform tasks after rendering\n    console.log("Component mounted");\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Determine if re-render is needed\n    return true;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // Perform tasks after update\n    console.log("Component updated");\n  }\n\n  componentWillUnmount() {\n    // Clean up resources before unmounting\n    console.log("Component unmounted");\n  }\n\n  handleClick() {\n    // Update state\n    this.setState((prevState) => ({\n      count: prevState.count + 1,\n    }));\n  }\n\n  render() {\n    // Render UI based on state and props\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// Functional Component\nfunction MyFunctionalComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // Perform tasks after initial render\n    console.log("Functional component mounted");\n\n    return () => {\n      // Clean up resources before unmounting\n      console.log("Functional component unmounted");\n    };\n  }, []);\n\n  useEffect(() => {\n    // Perform tasks after every render\n    console.log("Functional component updated");\n  });\n\n  const handleClick = () => {\n    // Update state\n    setCount((prevCount) => prevCount + 1);\n  };\n\n  // Render UI based on state and props\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n\n// Memoized Functional Component\nconst MemoizedFunctionalComponent = React.memo(MyFunctionalComponent);\n\n// Usage\nfunction App() {\n  return (\n    <div>\n      <h1>Class Component:</h1>\n      <MyComponent prop1="Hello" prop2={42} />\n\n      <h1>Functional Component:</h1>\n      <MyFunctionalComponent />\n\n      <h1>Memoized Functional Component:</h1>\n      <MemoizedFunctionalComponent />\n    </div>\n  );\n}\n\nexport default App;\n')),(0,a.kt)("p",null,"Feel free to run this code in a React project and check the console logs to understand."))}d.isMDXComponent=!0}}]);